#!/usr/bin/env perl
#
# git-shift - shifts timestamps of commits after the fact
#
# Copyright (c) 2010, 2012 Akinori MUSHA
#
# All rights reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
# OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
# OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
# SUCH DAMAGE.
#

use strict;
use warnings;
use Getopt::Long;
use IO::Select;
use IPC::Open3;
use POSIX qw(tzset tzname);
use Symbol 'gensym';
use Time::Local;
use Time::Piece 1.16;	# timezone support is required
use Time::Seconds;

my($opt_v, $opt_n, $opt_k);
my $exit_status = 0;

sub usage {
    print STDERR <<'EOS';
usage: git shift [options] {[<time>][<timediff>][timezone]|<datetime>} <rev-list>...

    -v, --verbose         be verbose
    -n, --dry-run         dry run
    -k                    skip errors

    <timediff>            add this time span to current commit time(s)
                          in regexp: /^[-+]([0-9]+[wdhms])+$/
                          e.g.
                            +1d -12h 30m -1h30m -600s

    <time>                substitute this value for the time part(s) of
                          current commit time(s)
                          one of:
                            - "HH:MM:SS"
                            - "HH:MM" (= "HH:MM:00")

    <timezone>            specify the time zone offset
                          in regexp: /^[-+][01][0-9][0-5][0-9]$/

    <datetime>            set this date time as commit time(s)
                          one of:
                            - ISO-8601 date time string
                            - date(1) format in C locale
                            - number of seconds since the Unix epoch
EOS
    exit 129;
}

sub main {
    Getopt::Long::Configure qw(no_getopt_compat require_order pass_through);
    GetOptions("v|verbose" => \$opt_v,
               "n|dry-run" => \$opt_n,
               "k"         => \$opt_k) or exit 64;
    pop @ARGV if @ARGV && $ARGV[$#ARGV] eq '--';
    $opt_v = 1  if $opt_n;

    if (!@ARGV) {
        usage();
    }

    my($timespec, @revspec) = @ARGV;
    my $function = parse_timespec($timespec);

    if (!defined($function)) {
        print STDERR "$0: error in time spec.\n";
        usage();
    }

    git_shift($function, @revspec);

    exit $exit_status;
}

sub may_exit {
    my($status) = @_ ? @_ : ($?);
    exit $status unless $opt_k;
    $exit_status = $status;
}

sub git_shift {
    my($function, @revspec) = @_;
    my $filter_main = compose_filter_main($function);
    chomp $filter_main;

    my @commits = revspec_to_commits(@revspec);

    if (!@commits) {
        print STDERR "$0: no revision specified\n";
        exit 64;
    }

    my @flags = qw(--force);

    for my $commit (@commits) {
        my $filter = <<"EOS";
[ \$GIT_COMMIT != $commit ] || {
$filter_main
}
EOS
        print "commit $commit\n";

        my $git = open3(my $in, my $out, my $err = gensym,
                        'git', 'filter-branch', @flags,
                        '--env-filter', $filter) or die $!;
        while (my $line = <$err>) {
            if ($line =~ /^git-shift /) {
                chomp $line;
                my($dummy, @pairs) = split(' ', $line);
                my @tuples;
                while (my($time, $tz) = splice(@pairs, 0, 2)) {
                    push @tuples, stringify_git_time($time, $tz);
                }
                my($atimestr, $ctimestr, $ntimestr) = @tuples;
                print "AuthorDate: $atimestr\n";
                print "CommitDate: $ctimestr\n";
                print "         => $ntimestr\n";
            } elsif ($line =~ /^WARNING: .* unchanged$/) {
                print $line unless $opt_n;
            } else {
                print $line;
            }
        }
        waitpid $git, 0;
        may_exit if $?;
    }
}

sub revspec_to_commits {
    my(@revspec) = @_;

    my @revs = do {
        my $git = open3(my $in, my $out, '>&2',
                        'git', 'rev-parse', @revspec) or die $!;
        my @out = <$out>;
        waitpid $git, 0;
        if ($?) {
            exit $?;
        }
        chomp(@out);
        @out;
    };
    if (grep(/[^0-9a-f]/, @revs)) {
        @revs = do {
            my $git = open3(my $in, my $out, '>&2',
                            'git', 'rev-list', @revs) or die $!;
            my @out = <$out>;
            waitpid $git, 0;
            if ($?) {
                exit $?;
            }
            chomp(@out);
            @out;
        };
    }

    @revs;
}

sub sh_functions {
    # SUSv4 only requires signed long precision in shell's arithmetic
    # expansion, hence bc(1) to avoid the year 2038 problem.
    <<'EOS';
st () {
 time="$1"; tz="$2"; func="$3"
 d='[0-9]'
 sign=`expr -- $tz : "\([-+]\)"`
 hh=`expr -- $tz : "[-+]\($d$d\)"`
 mm=`expr -- $tz : "[-+]$d$d\($d$d\)"`
 [ "$hh" = 0 ] || hh=${hh#0}
 [ "$mm" = 0 ] || mm=${mm#0}
 tzo="$(( $sign(60*(60*$hh+$mm)) ))"
 set -- $(bc <<EOF
define f(s,o) {
 $func
 s; o
}
f($time,$tzo)
EOF
 )
 ntime="$1"; ntzo="$2"
 case "$ntzo" in (-*) sign=- ;; (*) sign=+ ;; esac
 s="${ntzo#-}"
 ntz="$(printf '%s%02d%02d' "$sign" $((s/3600)) $((s%3600/60)))"
 echo "$ntime $ntz"
}
EOS
    # hh and mm above must always be two digit strings, but on OS X a
    # leading zero is eaten by a buggy expr(1) hence `[ .. = 0 ] ||`.
}

sub compose_filter_main {
    my($function) = @_;

    my $filter = sh_functions();

    $filter .= <<"EOS";
set -- \${GIT_AUTHOR_DATE#@} \${GIT_COMMITTER_DATE#@}
set -- "\$@" `st \$1 \$2 '$function'`
echo git-shift "\$@" >&2
EOS

    unless ($opt_n) {
        $filter .= <<'EOS';
GIT_AUTHOR_DATE="$5 $6"
GIT_COMMITTER_DATE="$5 $6"
EOS
    }

    $filter;
}

my $re_epoch	= qr/(?:0|[1-9][0-9]*)/;
my $re_tz	= qr/[-+][01][0-9][0-5][0-9]/;
my $re_span	= qr/[-+](?:[0-9]+[wdhms])+/;

sub parse_timespec {
    my($timespec) = @_;
    if ($timespec =~ /\A($re_epoch)($re_tz)?\z/o) {
        my($epoch, $tz) = ($1, $2);
        return join(
            ';',
            sprintf('s=%d', $epoch),
            defined($tz) ? sprintf('o=%d', parse_tz($tz)) : (),
        );
    } elsif ($timespec =~ /\A(?=.)(([0-9]{2}):([0-9]{2})(?::([0-9]{2}))?)?($re_span)?($re_tz)?\z/o) {
        my($hms, $h, $m, $s, $span, $tz) = ($1, $2, $3, $4, $5, $6);
        my $seconds;
        return join(
            ';',
            defined($span) && defined($seconds = parse_timediff($span)) ?
                sprintf('s+=%d', $seconds) : (),
            defined($hms) ? (
                's+=o',
                sprintf('s-=s%%%d', ONE_DAY),
                sprintf('s+=%d', $h * ONE_HOUR + $m * ONE_MINUTE + ($s || 0)),
                's-=o',
            ) : (),
            defined($tz) ? sprintf('o=%d', parse_tz($tz)) : (),
        );
    } else {
        my($time, $tzoffset) = eval {
            parse_date($timespec);
        };
        return sprintf('s=%d;o=%d', $time->epoch, $tzoffset) unless $@;
    }

    return undef;
}

sub parse_date {
    my($datetime) = @_;
    my($time, $tzoffset);

    if ($datetime =~ /\A([0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2})(Z|[-+][0-9]{4})?\z/){
        my($date, $tzsuffix) = ($1, $2);
        eval {
            if (!defined($tzsuffix)) {
                $time = localtime(Time::Piece->strptime($date, '%Y-%m-%dT%T'));
                $tzoffset = $time->tzoffset;
            } elsif ($tzsuffix eq 'Z') {
                $time = Time::Piece->strptime($date, '%Y-%m-%dT%T');
                $tzoffset = 0;
            } else {
                $time = Time::Piece->strptime($datetime, '%Y-%m-%dT%T%z');
                $tzoffset = parse_tz($tzsuffix);
            }
        };
        return ($time, $tzoffset) unless $@;
    };

    if ($datetime =~ /\A([A-Z][a-z]+\s+[A-Z][a-z]+\s+[0-9]{1,2}\s+[0-9]{2}:[0-9]{2}:[0-9]{2})\s+(?:UTC|GMT|([A-Z]+))\s+([0-9]+)\z/) {
        my($date, $tzname, $year) = ($1, $2, $3);
        eval {
            my @localtzname = grep { !/\A(UTC|GMT|WILDABBR)\z/ } do {
                POSIX::tzset();
                POSIX::tzname();
            };
            $time = Time::Piece->strptime("$date $year", '%a %b %d %T %Y');
            if (defined($tzname)) {
                grep { $_ eq $tzname } @localtzname or die 'unrecognized time zone name';
                $time = localtime(
                    timelocal($time->sec, $time->min, $time->hour,
                              $time->mday, $time->_mon, $time->year)
                );
                $tzoffset = $time->tzoffset;
            } else {
                $tzoffset = 0;
            }
        };
        return ($time, $tzoffset) unless $@;
    }

    die 'unrecognized date format';
}


sub parse_timediff {
    my($spec) = @_;
    my $value = 0;
    my $sign = ($spec =~ s/\A([-+])//) && $1;
    until ($spec eq '') {
        if ($spec =~ s/\A([0-9]+)([wdhms])//) {
            my $seconds = $1 * (
                $2 eq 'w' ? ONE_WEEK :
                $2 eq 'd' ? ONE_DAY :
                $2 eq 'h' ? ONE_HOUR :
                $2 eq 'm' ? ONE_MINUTE :
                1
            );
            if ($sign eq '-') {
                $value -= $seconds;
            } else {
                $value += $seconds;
            }
        } else {
            return undef;
        }
    }
    $value;
}

sub parse_tz {
    my($tz) = @_;
    my $t = gmtime();
    my $u = Time::Piece->strptime(
        $t->strftime("%Y-%m-%dT%H:%M:%S$tz"),
        '%Y-%m-%dT%H:%M:%S%z'
    );
    $t - $u;
}

sub stringify_git_time {
    my($time, $tz) = @_;
    my $t = gmtime($time) + parse_tz($tz);
    $t->strftime("%a %b %d %T %Y") . " $tz";
}

main();
